package app.logdate.server.auth

import app.logdate.server.passkeys.*
import com.webauthn4j.util.Base64UrlUtil
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlin.test.*
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid

@OptIn(ExperimentalUuidApi::class)
class PasskeyAccountCreationTest {

    private lateinit var accountRepository: AccountRepository
    private lateinit var passkeyService: PasskeyService
    private lateinit var sessionStorage: MutableMap<String, TemporarySession>

    @BeforeTest
    fun setup() {
        accountRepository = InMemoryAccountRepository()
        passkeyService = PasskeyService(
            relyingPartyId = "test.logdate.app",
            relyingPartyName = "LogDate Test",
            origin = "https://test.logdate.app"
        )
        sessionStorage = mutableMapOf()
    }

    @Test
    fun `begin account creation generates valid session and options`() {
        val request = BeginAccountCreationRequest(
            preferredUsername = "testuser",
            deviceInfo = DeviceInfo(
                platform = "android",
                deviceName = "Test Device",
                osVersion = "14",
                appVersion = "1.0.0",
                capabilities = listOf("uv", "rk", "up")
            )
        )

        val (sessionId, response) = beginAccountCreation(request)

        // Verify session was created
        assertTrue(sessionStorage.containsKey(sessionId))
        val session = sessionStorage[sessionId]!!
        
        assertEquals(SessionType.ACCOUNT_CREATION, session.sessionType)
        assertEquals("testuser", session.username)
        assertEquals(request.deviceInfo, session.deviceInfo)
        assertFalse(session.isUsed)

        // Verify response
        assertEquals(sessionId, response.sessionId)
        assertNotNull(response.challenge)
        assertNotNull(response.userId)
        
        // Verify registration options
        val options = response.registrationOptions
        assertEquals("test.logdate.app", options.rp.id)
        assertEquals("LogDate Test", options.rp.name)
        assertEquals("testuser", options.user.name)
        assertEquals("testuser", options.user.displayName) // Default to username
        assertNotNull(options.challenge)
        assertTrue(options.pubKeyCredParams.isNotEmpty())
    }

    @Test
    fun `begin account creation with no username generates one`() {
        val request = BeginAccountCreationRequest(
            deviceInfo = DeviceInfo(
                platform = "ios",
                deviceName = "iPhone"
            )
        )

        val (sessionId, response) = beginAccountCreation(request)

        val session = sessionStorage[sessionId]!!
        assertTrue(session.username.isNotBlank())
        assertTrue(session.username.length >= 4) // Should be reasonable length
        assertEquals(response.registrationOptions.user.name, session.username)
    }

    @Test
    fun `complete account creation with valid credential succeeds`() {
        // First begin account creation
        val beginRequest = BeginAccountCreationRequest(
            preferredUsername = "newuser",
            deviceInfo = DeviceInfo(platform = "web", deviceName = "Chrome")
        )
        
        val (sessionId, beginResponse) = beginAccountCreation(beginRequest)
        val session = sessionStorage[sessionId]!!

        // Create mock credential response
        val mockCredential = createMockRegistrationResponse("test_credential_123")
        
        val completeRequest = CompleteAccountCreationRequest(
            sessionId = sessionId,
            credential = mockCredential,
            accountPreferences = AccountPreferences(
                displayName = "New User",
                timezone = "America/New_York",
                locale = "en-US"
            )
        )

        // This would normally verify the credential, but we'll mock the success
        val response = simulateCompleteAccountCreation(completeRequest, session)

        assertTrue(response.success)
        assertEquals("newuser", response.account.username)
        assertEquals("New User", response.account.displayName)
        assertNotNull(response.session.accessToken)
        assertNotNull(response.session.refreshToken)
        assertEquals("test_credential_123", response.passkey.credentialId)
        assertTrue(response.syncData.initialSyncRequired)
    }

    @Test
    fun `complete account creation with invalid session fails`() {
        val mockCredential = createMockRegistrationResponse("test_credential")
        
        val completeRequest = CompleteAccountCreationRequest(
            sessionId = "invalid_session_id",
            credential = mockCredential
        )

        assertFailsWith<IllegalArgumentException> {
            getSessionAndValidate(completeRequest.sessionId, SessionType.ACCOUNT_CREATION)
        }
    }

    @Test
    fun `complete account creation with expired session fails`() {
        val expiredSession = TemporarySession(
            id = "expired_session",
            temporaryUserId = Uuid.random(),
            challenge = "expired_challenge",
            username = "testuser",
            deviceInfo = null,
            sessionType = SessionType.ACCOUNT_CREATION,
            createdAt = Clock.System.now().minus(kotlinx.datetime.DateTimePeriod(minutes = 10)),
            expiresAt = Clock.System.now().minus(kotlinx.datetime.DateTimePeriod(minutes = 5)), // Expired
            isUsed = false
        )
        
        sessionStorage["expired_session"] = expiredSession

        assertFailsWith<IllegalStateException> {
            getSessionAndValidate("expired_session", SessionType.ACCOUNT_CREATION)
        }
    }

    @Test
    fun `complete account creation with used session fails`() {
        val usedSession = TemporarySession(
            id = "used_session",
            temporaryUserId = Uuid.random(),
            challenge = "used_challenge",
            username = "testuser",
            deviceInfo = null,
            sessionType = SessionType.ACCOUNT_CREATION,
            createdAt = Clock.System.now(),
            expiresAt = Clock.System.now().plus(kotlinx.datetime.DateTimePeriod(minutes = 5)),
            isUsed = true // Already used
        )
        
        sessionStorage["used_session"] = usedSession

        assertFailsWith<IllegalStateException> {
            getSessionAndValidate("used_session", SessionType.ACCOUNT_CREATION)
        }
    }

    @Test
    fun `account creation enforces unique usernames`() {
        // Create first account
        val account1 = Account(
            id = Uuid.random(),
            username = "duplicate_user",
            displayName = "First User",
            createdAt = Clock.System.now()
        )

        runBlocking {
            accountRepository.save(account1)
            
            // Try to create session with same username
            val request = BeginAccountCreationRequest(preferredUsername = "duplicate_user")
            
            assertFailsWith<IllegalArgumentException> {
                beginAccountCreation(request)
            }
        }
    }

    @Test
    fun `username generation avoids collisions`() {
        // Pre-populate some usernames
        runBlocking {
            val existingAccount = Account(
                id = Uuid.random(),
                username = "user1234",
                displayName = "Existing User", 
                createdAt = Clock.System.now()
            )
            accountRepository.save(existingAccount)
        }

        val request = BeginAccountCreationRequest(
            deviceInfo = DeviceInfo(platform = "android", deviceName = "user")
        )

        val (_, response) = beginAccountCreation(request)
        val generatedUsername = response.registrationOptions.user.name

        // Should not collide with existing username
        assertNotEquals("user1234", generatedUsername)
        assertTrue(generatedUsername.startsWith("user") || generatedUsername.length >= 4)
    }

    @Test
    fun `device info is properly stored in session`() {
        val deviceInfo = DeviceInfo(
            platform = "ios",
            deviceName = "iPhone 15 Pro",
            osVersion = "17.1",
            appVersion = "2.1.0",
            capabilities = listOf("uv", "rk", "up", "hybrid")
        )

        val request = BeginAccountCreationRequest(
            preferredUsername = "devicetest",
            deviceInfo = deviceInfo
        )

        val (sessionId, _) = beginAccountCreation(request)
        val session = sessionStorage[sessionId]!!

        assertEquals(deviceInfo.platform, session.deviceInfo?.platform)
        assertEquals(deviceInfo.deviceName, session.deviceInfo?.deviceName)
        assertEquals(deviceInfo.osVersion, session.deviceInfo?.osVersion)
        assertEquals(deviceInfo.appVersion, session.deviceInfo?.appVersion)
        assertEquals(deviceInfo.capabilities, session.deviceInfo?.capabilities)
    }

    @Test
    fun `session expiration is set correctly`() {
        val request = BeginAccountCreationRequest(preferredUsername = "timetest")
        val beforeCreation = Clock.System.now()
        
        val (sessionId, _) = beginAccountCreation(request)
        val session = sessionStorage[sessionId]!!
        
        val afterCreation = Clock.System.now()

        // Session should be created between before and after timestamps
        assertTrue(session.createdAt >= beforeCreation)
        assertTrue(session.createdAt <= afterCreation)

        // Session should expire in 5 minutes
        val expectedExpiry = session.createdAt.plus(kotlinx.datetime.DateTimePeriod(minutes = 5))
        assertEquals(expectedExpiry, session.expiresAt)
    }

    // Helper methods to simulate the account creation flow

    private suspend fun beginAccountCreation(request: BeginAccountCreationRequest): Pair<String, BeginAccountCreationResponse> {
        // Check if username is already taken
        if (request.preferredUsername != null && accountRepository.usernameExists(request.preferredUsername)) {
            throw IllegalArgumentException("Username already exists")
        }

        val temporaryUserId = Uuid.random()
        val sessionId = Uuid.random().toString()
        val username = request.preferredUsername ?: generateUsername(request.deviceInfo?.deviceName)

        val options = passkeyService.generateRegistrationOptions(
            userId = temporaryUserId,
            username = username,
            displayName = username // Default display name to username
        )

        val session = TemporarySession(
            id = sessionId,
            temporaryUserId = temporaryUserId,
            challenge = options.challenge,
            username = username,
            deviceInfo = request.deviceInfo,
            sessionType = SessionType.ACCOUNT_CREATION,
            createdAt = Clock.System.now(),
            expiresAt = Clock.System.now().plus(kotlinx.datetime.DateTimePeriod(minutes = 5))
        )

        sessionStorage[sessionId] = session

        val response = BeginAccountCreationResponse(
            challenge = options.challenge,
            userId = Base64UrlUtil.encodeToString(temporaryUserId.toString().toByteArray()),
            sessionId = sessionId,
            registrationOptions = options
        )

        return sessionId to response
    }

    private fun simulateCompleteAccountCreation(
        request: CompleteAccountCreationRequest,
        session: TemporarySession
    ): AccountCreationResponse {
        val accountId = Uuid.random()
        val now = Clock.System.now()

        val account = Account(
            id = accountId,
            username = session.username,
            displayName = request.accountPreferences?.displayName ?: session.username,
            createdAt = now,
            timezone = request.accountPreferences?.timezone,
            locale = request.accountPreferences?.locale
        )

        val accountInfo = AccountInfo(
            userId = account.id,
            username = account.username,
            displayName = account.displayName,
            createdAt = account.createdAt
        )

        val sessionTokens = SessionTokens(
            accessToken = "mock_access_token",
            refreshToken = "mock_refresh_token",
            expiresIn = 3600
        )

        val passkeySummary = app.logdate.server.routes.PasskeySummaryResponse(
            id = Uuid.random(),
            credentialId = request.credential.id,
            nickname = "${session.deviceInfo?.deviceName ?: "Device"} Passkey",
            deviceType = if (session.deviceInfo?.platform in listOf("android", "ios")) "platform" else "cross-platform",
            createdAt = now.toString(),
            lastUsedAt = null,
            isActive = true
        )

        val syncData = SyncData(
            serverEndpoint = "https://api.logdate.app",
            initialSyncRequired = true
        )

        return AccountCreationResponse(
            success = true,
            account = accountInfo,
            session = sessionTokens,
            passkey = passkeySummary,
            syncData = syncData
        )
    }

    private fun getSessionAndValidate(sessionId: String, expectedType: SessionType): TemporarySession {
        val session = sessionStorage[sessionId] ?: throw IllegalArgumentException("Session not found")
        
        if (session.sessionType != expectedType) {
            throw IllegalArgumentException("Invalid session type")
        }
        
        if (session.isUsed) {
            throw IllegalStateException("Session already used")
        }
        
        if (Clock.System.now() > session.expiresAt) {
            throw IllegalStateException("Session expired")
        }
        
        return session
    }

    private fun generateUsername(deviceName: String?): String {
        val base = deviceName?.let { name ->
            name.replace(Regex("[^a-zA-Z0-9]"), "")
                .take(8)
                .lowercase()
        } ?: "user"
        
        val suffix = (1000..9999).random()
        return "${base}${suffix}"
    }

    private fun createMockRegistrationResponse(credentialId: String = "test_credential"): PasskeyRegistrationResponse {
        return PasskeyRegistrationResponse(
            id = credentialId,
            rawId = Base64UrlUtil.encodeToString(credentialId.toByteArray()),
            response = AuthenticatorAttestationResponse(
                clientDataJSON = Base64UrlUtil.encodeToString("""{"type":"webauthn.create","challenge":"test","origin":"https://test.logdate.app"}""".toByteArray()),
                attestationObject = Base64UrlUtil.encodeToString("mock_attestation".toByteArray()),
                transports = listOf("internal")
            )
        )
    }

    // Mock coroutine support for testing
    private fun <T> runBlocking(block: suspend () -> T): T {
        return kotlinx.coroutines.runBlocking { block() }
    }
}