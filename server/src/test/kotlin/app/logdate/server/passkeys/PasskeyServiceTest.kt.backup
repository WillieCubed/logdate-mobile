package app.logdate.server.passkeys

import com.webauthn4j.util.Base64UrlUtil
import kotlinx.coroutines.test.runTest
import kotlin.test.*
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid

@OptIn(ExperimentalUuidApi::class)
class PasskeyServiceTest {
    
    private lateinit var passkeyService: PasskeyService
    private val testUserId = Uuid.random()
    private val testUsername = "testuser"
    private val testDisplayName = "Test User"
    
    @BeforeTest
    fun setup() {
        passkeyService = PasskeyService(
            relyingPartyId = "test.logdate.app",
            relyingPartyName = "LogDate Test",
            origin = "https://test.logdate.app"
        )
    }
    
    @Test
    fun `generateRegistrationOptions creates valid options`() = runTest {
        val options = passkeyService.generateRegistrationOptions(
            userId = testUserId,
            username = testUsername,
            displayName = testDisplayName
        )
        
        // Verify relying party
        assertEquals("test.logdate.app", options.rp.id)
        assertEquals("LogDate Test", options.rp.name)
        
        // Verify user entity
        assertEquals(testUsername, options.user.name)
        assertEquals(testDisplayName, options.user.displayName)
        assertNotNull(options.user.id)
        
        // Verify challenge
        assertNotNull(options.challenge)
        assertTrue(options.challenge.isNotEmpty())
        
        // Verify public key credential parameters
        assertTrue(options.pubKeyCredParams.isNotEmpty())
        assertTrue(options.pubKeyCredParams.any { it.alg == -7 }) // ES256
        assertTrue(options.pubKeyCredParams.any { it.alg == -257 }) // RS256
        
        // Verify timeout
        assertEquals(300_000L, options.timeout)
        
        // Verify authenticator selection
        assertNotNull(options.authenticatorSelection)
        assertEquals("preferred", options.authenticatorSelection?.residentKey)
        assertEquals("preferred", options.authenticatorSelection?.userVerification)
        assertFalse(options.authenticatorSelection?.requireResidentKey ?: true)
        
        // Verify attestation
        assertEquals("none", options.attestation)
    }
    
    @Test
    fun `generateAuthenticationOptions creates valid options`() = runTest {
        val options = passkeyService.generateAuthenticationOptions(
            userId = testUserId
        )
        
        // Verify challenge
        assertNotNull(options.challenge)
        assertTrue(options.challenge.isNotEmpty())
        
        // Verify RP ID
        assertEquals("test.logdate.app", options.rpId)
        
        // Verify timeout
        assertEquals(300_000L, options.timeout)
        
        // Verify user verification
        assertEquals("preferred", options.userVerification)
        
        // Verify allowed credentials (should be empty for new user)
        assertTrue(options.allowCredentials.isEmpty())
    }
    
    @Test
    fun `generateAuthenticationOptions with allowed credentials`() = runTest {
        val allowedCredentials = listOf("credential1", "credential2")
        
        val options = passkeyService.generateAuthenticationOptions(
            userId = testUserId,
            allowedCredentials = allowedCredentials
        )
        
        assertEquals(2, options.allowCredentials.size)
        assertEquals("credential1", options.allowCredentials[0].id)
        assertEquals("credential2", options.allowCredentials[1].id)
        
        options.allowCredentials.forEach { descriptor ->
            assertEquals("public-key", descriptor.type)
            assertTrue(descriptor.transports.isNotEmpty())
        }
    }
    
    @Test
    fun `verifyRegistration fails with invalid challenge`() = runTest {
        val mockResponse = createMockRegistrationResponse()
        val invalidChallenge = "invalid_challenge"
        
        val result = passkeyService.verifyRegistration(mockResponse, invalidChallenge)
        
        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull()?.message?.contains("Invalid or expired challenge") == true)
    }
    
    @Test
    fun `verifyAuthentication fails with invalid challenge`() = runTest {
        val mockResponse = createMockAuthenticationResponse()
        val invalidChallenge = "invalid_challenge"
        
        val result = passkeyService.verifyAuthentication(mockResponse, invalidChallenge)
        
        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull()?.message?.contains("Invalid or expired challenge") == true)
    }
    
    @Test
    fun `verifyAuthentication fails with non-existent passkey`() = runTest {
        // First generate valid challenge
        val authOptions = passkeyService.generateAuthenticationOptions(testUserId)
        val challenge = authOptions.challenge
        
        val mockResponse = createMockAuthenticationResponse("non_existent_credential")
        
        val result = passkeyService.verifyAuthentication(mockResponse, challenge)
        
        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull()?.message?.contains("Passkey not found") == true)
    }
    
    @Test
    fun `getPasskeysForUser returns empty list for new user`() = runTest {
        val passkeys = passkeyService.getPasskeysForUser(testUserId)
        
        assertTrue(passkeys.isEmpty())
    }
    
    @Test
    fun `deletePasskey with non-existent credential returns false`() = runTest {
        val result = passkeyService.deletePasskey("non_existent", testUserId)
        
        assertFalse(result)
    }
    
    @Test
    fun `deletePasskey with wrong user returns false`() = runTest {
        // This test would require setting up a passkey first, 
        // but since we can't easily mock WebAuthn verification,
        // we test the basic authorization logic
        val wrongUserId = Uuid.random()
        val result = passkeyService.deletePasskey("any_credential", wrongUserId)
        
        assertFalse(result)
    }
    
    @Test
    fun `challenge generation produces unique values`() = runTest {
        val options1 = passkeyService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        val options2 = passkeyService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        
        assertNotEquals(options1.challenge, options2.challenge)
    }
    
    @Test
    fun `challenge is properly base64url encoded`() = runTest {
        val options = passkeyService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        
        // Should not throw exception when decoding
        assertNotNull(Base64UrlUtil.decode(options.challenge))
        
        // Should be 32 bytes (256 bits) when decoded
        val decoded = Base64UrlUtil.decode(options.challenge)
        assertEquals(32, decoded.size)
    }
    
    @Test
    fun `user entity id is properly encoded`() = runTest {
        val options = passkeyService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        
        // Should not throw exception when decoding
        val decodedUserId = Base64UrlUtil.decode(options.user.id)
        assertNotNull(decodedUserId)
        
        // Should be able to reconstruct the user ID
        val reconstructedUserId = String(decodedUserId)
        assertEquals(testUserId.toString(), reconstructedUserId)
    }
    
    @Test
    fun `excludeCredentials populated for user with existing passkeys`() = runTest {
        // This would require a more complex setup to test properly
        // For now, test that new user has no excluded credentials
        val options = passkeyService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        
        assertTrue(options.excludeCredentials.isEmpty())
    }
    
    @Test
    fun `service uses correct default values`() = runTest {
        val defaultService = PasskeyService()
        
        val options = defaultService.generateRegistrationOptions(testUserId, testUsername, testDisplayName)
        
        assertEquals("logdate.app", options.rp.id)
        assertEquals("LogDate", options.rp.name)
    }
    
    @Test
    fun `authentication options without userId generates valid challenge`() = runTest {
        val options = passkeyService.generateAuthenticationOptions()
        
        assertNotNull(options.challenge)
        assertTrue(options.challenge.isNotEmpty())
        assertEquals("test.logdate.app", options.rpId)
        assertTrue(options.allowCredentials.isEmpty())
    }
    
    // Helper methods for creating mock responses
    private fun createMockRegistrationResponse(credentialId: String = "test_credential"): PasskeyRegistrationResponse {
        return PasskeyRegistrationResponse(
            id = credentialId,
            rawId = Base64UrlUtil.encodeToString(credentialId.toByteArray()),
            response = AuthenticatorAttestationResponse(
                clientDataJSON = Base64UrlUtil.encodeToString("""{"type":"webauthn.create","challenge":"test_challenge","origin":"https://test.logdate.app"}""".toByteArray()),
                attestationObject = Base64UrlUtil.encodeToString("mock_attestation_object".toByteArray()),
                transports = listOf("internal")
            )
        )
    }
    
    private fun createMockAuthenticationResponse(credentialId: String = "test_credential"): PasskeyAuthenticationResponse {
        return PasskeyAuthenticationResponse(
            id = credentialId,
            rawId = Base64UrlUtil.encodeToString(credentialId.toByteArray()),
            response = AuthenticatorAssertionResponse(
                clientDataJSON = Base64UrlUtil.encodeToString("""{"type":"webauthn.get","challenge":"test_challenge","origin":"https://test.logdate.app"}""".toByteArray()),
                authenticatorData = Base64UrlUtil.encodeToString("mock_authenticator_data".toByteArray()),
                signature = Base64UrlUtil.encodeToString("mock_signature".toByteArray()),
                userHandle = Base64UrlUtil.encodeToString(testUserId.toString().toByteArray())
            )
        )
    }
}