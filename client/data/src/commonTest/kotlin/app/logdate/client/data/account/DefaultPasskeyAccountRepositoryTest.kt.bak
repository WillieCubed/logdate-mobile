package app.logdate.client.data.account

import app.logdate.client.datastore.SessionStorage
import app.logdate.client.datastore.UserSession
import app.logdate.client.device.PlatformAccountManager
import app.logdate.client.networking.PasskeyApiClient
import app.logdate.client.permissions.PasskeyManager
import app.logdate.client.repository.account.AccountCreationRequest
import app.logdate.shared.config.LogDateConfigRepository
import app.logdate.shared.model.AccountTokens
import app.logdate.shared.model.BeginAccountCreationData
import app.logdate.shared.model.BeginAccountCreationRequest
import app.logdate.shared.model.BeginAccountCreationResponse
import app.logdate.shared.model.BeginAuthenticationData
import app.logdate.shared.model.BeginAuthenticationRequest
import app.logdate.shared.model.BeginAuthenticationResponse
import app.logdate.shared.model.CompleteAccountCreationData
import app.logdate.shared.model.CompleteAccountCreationRequest
import app.logdate.shared.model.CompleteAccountCreationResponse
import app.logdate.shared.model.CompleteAuthenticationData
import app.logdate.shared.model.CompleteAuthenticationRequest
import app.logdate.shared.model.CompleteAuthenticationResponse
import app.logdate.shared.model.LogDateAccount
import app.logdate.shared.model.PasskeyAllowCredential
import app.logdate.shared.model.PasskeyAssertionResponse
import app.logdate.shared.model.PasskeyAuthenticationOptions
import app.logdate.shared.model.PasskeyCredentialResponse
import app.logdate.shared.model.PasskeyRegistrationOptions
import app.logdate.shared.model.PasskeyUser
import app.logdate.shared.model.UsernameAvailabilityData
import app.logdate.shared.model.UsernameAvailabilityResponse
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.test.runTest
import kotlinx.datetime.Clock
import kotlinx.serialization.json.Json
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid

@OptIn(ExperimentalUuidApi::class)
class DefaultPasskeyAccountRepositoryTest {

    private val testAccount = LogDateAccount(
        id = Uuid.random(),
        username = "testuser",
        displayName = "Test User",
        bio = "Test bio",
        createdAt = Clock.System.now(),
        updatedAt = Clock.System.now()
    )

    private val testTokens = AccountTokens(
        accessToken = "access_token_123",
        refreshToken = "refresh_token_123"
    )

    private val testSession = UserSession(
        accessToken = testTokens.accessToken,
        refreshToken = testTokens.refreshToken,
        accountId = testAccount.id.toString()
    )

    private fun createRepository(
        apiClient: PasskeyApiClient = MockPasskeyApiClient(),
        passkeyManager: PasskeyManager = MockPasskeyManager(),
        sessionStorage: SessionStorage = MockSessionStorage(),
        platformAccountManager: PlatformAccountManager = MockPlatformAccountManager(),
        configRepository: LogDateConfigRepository = MockConfigRepository()
    ): DefaultPasskeyAccountRepository {
        return DefaultPasskeyAccountRepository(
            apiClient = apiClient,
            passkeyManager = passkeyManager,
            sessionStorage = sessionStorage,
            platformAccountManager = platformAccountManager,
            configRepository = configRepository
        )
    }

    @Test
    fun `initialization with existing session sets authenticated state`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        
        val repository = createRepository(sessionStorage = sessionStorage)
        
        assertTrue(repository.isAuthenticated.value)
    }

    @Test
    fun `initialization without session sets unauthenticated state`() = runTest {
        val repository = createRepository()
        
        assertFalse(repository.isAuthenticated.value)
        assertNull(repository.currentAccount.value)
    }

    @Test
    fun `checkUsernameAvailability returns available when username is free`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            usernameAvailabilityResponse = Result.success(UsernameAvailabilityResponse(
                success = true,
                data = UsernameAvailabilityData(username = "newuser", available = true)
            ))
        }
        
        val repository = createRepository(apiClient = apiClient)
        val result = repository.checkUsernameAvailability("newuser")
        
        assertTrue(result.isSuccess)
        assertTrue(result.getOrThrow())
    }

    @Test
    fun `checkUsernameAvailability returns unavailable when username is taken`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            usernameAvailabilityResponse = Result.success(UsernameAvailabilityResponse(
                success = true,
                data = UsernameAvailabilityData(username = "existinguser", available = false)
            ))
        }
        
        val repository = createRepository(apiClient = apiClient)
        val result = repository.checkUsernameAvailability("existinguser")
        
        assertTrue(result.isSuccess)
        assertFalse(result.getOrThrow())
    }

    @Test
    fun `checkUsernameAvailability handles API error`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            usernameAvailabilityResponse = Result.failure(Exception("Network error"))
        }
        
        val repository = createRepository(apiClient = apiClient)
        val result = repository.checkUsernameAvailability("testuser")
        
        assertTrue(result.isFailure)
    }

    @Test
    fun `createAccountWithPasskey succeeds with valid flow`() = runTest {
        val sessionStorage = MockSessionStorage()
        val platformAccountManager = MockPlatformAccountManager()
        val configRepository = MockConfigRepository()
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            platformAccountManager = platformAccountManager,
            configRepository = configRepository
        )
        
        val request = AccountCreationRequest(
            username = "newuser",
            displayName = "New User",
            bio = "New user bio"
        )
        
        val result = repository.createAccountWithPasskey(request)
        
        assertTrue(result.isSuccess)
        assertEquals(testAccount, result.getOrThrow())
        assertTrue(repository.isAuthenticated.value)
        assertEquals(testAccount, repository.currentAccount.value)
        
        // Verify session was stored
        val storedSession = sessionStorage.getSession()
        assertNotNull(storedSession)
        assertEquals(testTokens.accessToken, storedSession.accessToken)
        assertEquals(testTokens.refreshToken, storedSession.refreshToken)
        assertEquals(testAccount.id.toString(), storedSession.accountId)
    }

    @Test
    fun `createAccountWithPasskey handles begin account creation failure`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            beginAccountCreationResponse = Result.failure(Exception("Username already exists"))
        }
        
        val repository = createRepository(apiClient = apiClient)
        
        val request = AccountCreationRequest(
            username = "existinguser",
            displayName = "User",
            bio = "Bio"
        )
        
        val result = repository.createAccountWithPasskey(request)
        
        assertTrue(result.isFailure)
        assertFalse(repository.isAuthenticated.value)
        assertNull(repository.currentAccount.value)
    }

    @Test
    fun `createAccountWithPasskey handles passkey registration failure`() = runTest {
        val passkeyManager = MockPasskeyManager().apply {
            registerPasskeyResponse = Result.failure(Exception("User cancelled"))
        }
        
        val repository = createRepository(passkeyManager = passkeyManager)
        
        val request = AccountCreationRequest(
            username = "newuser",
            displayName = "User",
            bio = "Bio"
        )
        
        val result = repository.createAccountWithPasskey(request)
        
        assertTrue(result.isFailure)
        assertFalse(repository.isAuthenticated.value)
    }

    @Test
    fun `createAccountWithPasskey handles complete account creation failure`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            completeAccountCreationResponse = Result.failure(Exception("Invalid credential"))
        }
        
        val repository = createRepository(apiClient = apiClient)
        
        val request = AccountCreationRequest(
            username = "newuser",
            displayName = "User",
            bio = "Bio"
        )
        
        val result = repository.createAccountWithPasskey(request)
        
        assertTrue(result.isFailure)
        assertFalse(repository.isAuthenticated.value)
    }

    @Test
    fun `authenticateWithPasskey succeeds with valid flow`() = runTest {
        val sessionStorage = MockSessionStorage()
        val platformAccountManager = MockPlatformAccountManager()
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            platformAccountManager = platformAccountManager
        )
        
        val result = repository.authenticateWithPasskey("testuser")
        
        assertTrue(result.isSuccess)
        assertEquals(testAccount, result.getOrThrow())
        assertTrue(repository.isAuthenticated.value)
        assertEquals(testAccount, repository.currentAccount.value)
        
        // Verify session was stored
        val storedSession = sessionStorage.getSession()
        assertNotNull(storedSession)
        assertEquals(testTokens.accessToken, storedSession.accessToken)
        assertEquals(testTokens.refreshToken, storedSession.refreshToken)
        assertEquals(testAccount.id.toString(), storedSession.accountId)
    }

    @Test
    fun `authenticateWithPasskey handles begin authentication failure`() = runTest {
        val apiClient = MockPasskeyApiClient().apply {
            beginAuthenticationResponse = Result.failure(Exception("User not found"))
        }
        
        val repository = createRepository(apiClient = apiClient)
        val result = repository.authenticateWithPasskey("nonexistentuser")
        
        assertTrue(result.isFailure)
        assertFalse(repository.isAuthenticated.value)
    }

    @Test
    fun `authenticateWithPasskey handles passkey authentication failure`() = runTest {
        val passkeyManager = MockPasskeyManager().apply {
            authenticateWithPasskeyResponse = Result.failure(Exception("Authentication failed"))
        }
        
        val repository = createRepository(passkeyManager = passkeyManager)
        val result = repository.authenticateWithPasskey("testuser")
        
        assertTrue(result.isFailure)
        assertFalse(repository.isAuthenticated.value)
    }

    @Test
    fun `signOut clears session and resets state`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val platformAccountManager = MockPlatformAccountManager()
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            platformAccountManager = platformAccountManager
        )
        
        // Set up authenticated state
        repository.createAccountWithPasskey(
            AccountCreationRequest("user", "User", "Bio")
        )
        
        val result = repository.signOut()
        
        assertTrue(result.isSuccess)
        assertFalse(repository.isAuthenticated.value)
        assertNull(repository.currentAccount.value)
        assertNull(sessionStorage.getSession())
    }

    @Test
    fun `refreshAuthentication succeeds with valid refresh token`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            refreshTokenResponse = Result.success("new_access_token")
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.refreshAuthentication()
        
        assertTrue(result.isSuccess)
        
        // Verify session was updated with new access token
        val updatedSession = sessionStorage.getSession()
        assertNotNull(updatedSession)
        assertEquals("new_access_token", updatedSession.accessToken)
        assertEquals(testTokens.refreshToken, updatedSession.refreshToken)
    }

    @Test
    fun `refreshAuthentication clears session on failure`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            refreshTokenResponse = Result.failure(Exception("Invalid refresh token"))
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.refreshAuthentication()
        
        assertTrue(result.isFailure)
        assertNull(sessionStorage.getSession())
        assertFalse(repository.isAuthenticated.value)
    }

    @Test
    fun `getAccountInfo succeeds with valid session`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            getAccountInfoResponse = Result.success(testAccount)
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.getAccountInfo()
        
        assertTrue(result.isSuccess)
        assertEquals(testAccount, result.getOrThrow())
        assertEquals(testAccount, repository.currentAccount.value)
    }

    @Test
    fun `getAccountInfo retries after token refresh on authentication failure`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            // First call fails, second succeeds after refresh
            refreshTokenResponse = Result.success("new_access_token")
            
            // Override to simulate retry behavior
            getAccountInfoResponses = listOf(
                Result.failure(Exception("Unauthorized")),
                Result.success(testAccount)
            )
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.getAccountInfo()
        
        assertTrue(result.isSuccess)
        assertEquals(testAccount, result.getOrThrow())
    }

    @Test
    fun `deletePasskey succeeds with valid session`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            deletePasskeyResponse = Result.success(Unit)
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.deletePasskey("credential123")
        
        assertTrue(result.isSuccess)
    }

    @Test
    fun `deletePasskey retries after token refresh on authentication failure`() = runTest {
        val sessionStorage = MockSessionStorage().apply {
            saveSession(testSession)
        }
        val apiClient = MockPasskeyApiClient().apply {
            refreshTokenResponse = Result.success("new_access_token")
            deletePasskeyResponses = listOf(
                Result.failure(Exception("Unauthorized")),
                Result.success(Unit)
            )
        }
        
        val repository = createRepository(
            sessionStorage = sessionStorage,
            apiClient = apiClient
        )
        
        val result = repository.deletePasskey("credential123")
        
        assertTrue(result.isSuccess)
    }

    @Test
    fun `getCurrentAccount returns current account state`() = runTest {
        val repository = createRepository()
        
        // Initially null
        assertNull(repository.getCurrentAccount())
        
        // After successful account creation
        repository.createAccountWithPasskey(
            AccountCreationRequest("user", "User", "Bio")
        )
        
        assertEquals(testAccount, repository.getCurrentAccount())
    }

    // Mock implementations
    private class MockPasskeyApiClient : PasskeyApiClient {
        var usernameAvailabilityResponse = Result.success(UsernameAvailabilityResponse(
            success = true,
            data = UsernameAvailabilityData(username = "test", available = true)
        ))
        var beginAccountCreationResponse = Result.success(
            BeginAccountCreationResponse(
                success = true,
                data = BeginAccountCreationData(
                    sessionToken = "session123",
                    registrationOptions = PasskeyRegistrationOptions(
                        challenge = "challenge123",
                        user = PasskeyUser(
                            id = "user123",
                            name = "testuser",
                            displayName = "Test User"
                        ),
                        timeout = 300000
                    )
                )
            )
        )
        var completeAccountCreationResponse = Result.success(
            CompleteAccountCreationResponse(
                success = true,
                data = CompleteAccountCreationData(
                    account = testAccount,
                    tokens = testTokens
                )
            )
        )
        var beginAuthenticationResponse = Result.success(
            BeginAuthenticationResponse(
                success = true,
                data = BeginAuthenticationData(
                    challenge = "challenge123",
                    rpId = "logdate.app",
                    allowCredentials = listOf(
                        PasskeyAllowCredential(id = "cred123", type = "public-key", transports = listOf("internal"))
                    ),
                    timeout = 300000,
                    userVerification = "preferred"
                )
            )
        )
        var completeAuthenticationResponse = Result.success(
            CompleteAuthenticationResponse(
                success = true,
                data = CompleteAuthenticationData(
                    account = testAccount,
                    tokens = testTokens
                )
            )
        )
        var refreshTokenResponse = Result.success("new_access_token")
        var getAccountInfoResponse = Result.success(testAccount)
        var getAccountInfoResponses: List<Result<LogDateAccount>>? = null
        var deletePasskeyResponse = Result.success(Unit)
        var deletePasskeyResponses: List<Result<Unit>>? = null

        private var getAccountInfoCallCount = 0
        private var deletePasskeyCallCount = 0

        override suspend fun checkUsernameAvailability(username: String): Result<UsernameAvailabilityResponse> {
            return usernameAvailabilityResponse
        }

        override suspend fun beginAccountCreation(request: BeginAccountCreationRequest): Result<BeginAccountCreationResponse> {
            return beginAccountCreationResponse
        }

        override suspend fun completeAccountCreation(request: CompleteAccountCreationRequest): Result<CompleteAccountCreationResponse> {
            return completeAccountCreationResponse
        }

        override suspend fun beginAuthentication(request: BeginAuthenticationRequest): Result<BeginAuthenticationResponse> {
            return beginAuthenticationResponse
        }

        override suspend fun completeAuthentication(request: CompleteAuthenticationRequest): Result<CompleteAuthenticationResponse> {
            return completeAuthenticationResponse
        }

        override suspend fun refreshToken(refreshToken: String): Result<String> {
            return refreshTokenResponse
        }

        override suspend fun getAccountInfo(accessToken: String): Result<LogDateAccount> {
            return getAccountInfoResponses?.let { responses ->
                responses[getAccountInfoCallCount++.coerceAtMost(responses.size - 1)]
            } ?: getAccountInfoResponse
        }

        override suspend fun deletePasskey(accessToken: String, credentialId: String): Result<Unit> {
            return deletePasskeyResponses?.let { responses ->
                responses[deletePasskeyCallCount++.coerceAtMost(responses.size - 1)]
            } ?: deletePasskeyResponse
        }
    }

    private class MockPasskeyManager : PasskeyManager {
        var registerPasskeyResponse = Result.success("""{"type":"public-key","id":"credential123"}""")
        var authenticateWithPasskeyResponse = Result.success("""{"type":"public-key","id":"credential123"}""")

        override suspend fun registerPasskey(options: PasskeyRegistrationOptions): Result<String> {
            return registerPasskeyResponse
        }

        override suspend fun authenticateWithPasskey(options: PasskeyAuthenticationOptions): Result<String> {
            return authenticateWithPasskeyResponse
        }
    }

    private class MockSessionStorage : SessionStorage {
        private var session: UserSession? = null

        override fun saveSession(session: UserSession) {
            this.session = session
        }

        override fun getSession(): UserSession? {
            return session
        }

        override fun clearSession() {
            session = null
        }
    }

    private class MockPlatformAccountManager : PlatformAccountManager {
        var addAccountResponse = Result.success(Unit)
        var updateTokensResponse = Result.success(Unit)

        override suspend fun addAccount(
            account: LogDateAccount,
            accessToken: String,
            refreshToken: String,
            backendUrl: String
        ): Result<Unit> {
            return addAccountResponse
        }

        override suspend fun updateTokens(
            username: String,
            accessToken: String,
            refreshToken: String
        ): Result<Unit> {
            return updateTokensResponse
        }

        override suspend fun removeAccount(username: String): Result<Unit> {
            return Result.success(Unit)
        }

        override suspend fun getStoredAccounts(): Result<List<LogDateAccount>> {
            return Result.success(emptyList())
        }
    }

    private class MockConfigRepository : LogDateConfigRepository {
        override fun getCurrentBackendUrl(): String = "https://api.logdate.app"
        override fun setBackendUrl(url: String) {}
        override fun resetToDefault() {}
        override val backendUrl: StateFlow<String> = MutableStateFlow("https://api.logdate.app").asStateFlow()
    }
}